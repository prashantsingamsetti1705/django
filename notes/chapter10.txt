CHAPTER-10:Class Based Views and CRUD OPerations by using CBVs and FBVs
======================================================================
CRUD Operations:
	FBVs==>Function Based Views
	CBVs==>Class Based Views
	Django ORM

C --->Create (Insert Operations)
R --->Retrieve/Read(select query)
U --->Update(update)
D --->Delete(delete)

CRUD operations FBV's
-----------------------------------
django-admin startproject fbvproject
py manage.py startapp testapp
Add app in settings.py

models.py
----------------
class Employee(models.Model):
    eno = models.IntegerField()
    ename = models.CharField(max_length=64)
    esal = models.FloatField()
    eaddr = models.CharField(max_length=128)

-->makemigrations and migrate

admin.py
--------------
from testapp.models import Employee
class EmployeeAdmin(admin.ModelAdmin):
    list_display = ['eno','ename','esal','eaddr']
admin.site.register(Employee,EmployeeAdmin)

-->create super user

populate.py
------------------
import os
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'fbvproject.settings')
import django
django.setup()

from faker import Faker
from testapp.models import Employee
from random import *
fake = Faker()

def populate(n):
    for i in range(n):
        feno = randint(1001,9999)
        fename = fake.name()
        fesal = randint(10000,20000)
        feaddr = fake.city()
        emp_record = Employee.objects.get_or_create(
            eno = feno,
            ename = fename,
            esal = fesal,
            eaddr = feaddr)
n = int(input('Enter number of employees:'))
populate(n)
print(f'{n} Records inserted successfully.....')

views.py
-------------
from testapp.models import Employee
def retrieve_view(request):
    emp_list = Employee.objects.all()
    return render(request,'testapp/index.html',{'emp_list':emp_list})

base.html
---------------
<body>
    <div class="container" align="center">
        {% block body_block %}
        {% endblock %}
    </div>
</body>

index.html
-----------------
<!DOCTYPE html>
{% extends 'testapp/base.html' %}
{% block body_block %}
<h1>Welcome To Employee List</h1><hr>
<table border="3">
  <thead>
    <th>Employee Number</th>
    <th>Employee Name</th>
    <th>Employee Salary</th>
    <th>Employee Address</th>
    <th>Actions</th>
  </thead>
  {% for emp in emp_list %}
  <tr>
    <td>{{emp.eno}}</td>
    <td>{{emp.ename}}</td>
    <td>{{emp.esal}}</td>
    <td>{{emp.eaddr}}</td>
    <td><a href="#">Update</a>&nbsp&nbsp&nbsp
    <a href="#">Delete</a></td>
  </tr>
  {% endfor %}
</table>
<br><br>
<a href="#" class="btn btn-success">Insert New Employee</a>
{% endblock %}
forms.py
-------------
from django import forms
from testapp.models import Employee
class EmployeeForm(forms.ModelForm):
    class Meta:
        model = Employee
        fields = '__all__'

views.py
-------------
from testapp.forms import EmployeeForm
def insert_view(request):
    form = EmployeeForm()
    return render(request,'testapp/insert.html',{'form':form})

insert.html
-----------------
<!DOCTYPE html>
{% extends 'testapp/base.html' %}
{% block body_block %}
<h1>Employee Insert Form</h1><hr>
<form method="post">
    {{form.as_p}}
    {% csrf_token %}
    <input class="btn btn-success btn-lg" type="submit" value="Insert Record">
</form>
{% endblock %}

urls.py: path('insert/',views.insert_view)

views.py
-------------
rom django.shortcuts import render,redirect
def insert_view(request):
    form = EmployeeForm()
    if request.method == 'POST':
        form = EmployeeForm(request.POST)
        if form.is_valid():
            form.save()
        return redirect('/')
    return render(request,'testapp/insert.html',{'form':form})

DELETE:
--------------
views.py
-------------
def delete_view(reqest,id):
    employee = Employee.objects.get(id=id)
    employee.delete()
    return redirect('/')

step-1:index.html:
	<a href="/delete/{{emp.id}}">Delete</a></td>

step-2:urls.py:
	path('delete/<int:id>', views.delete_view)

UPDATE:
--------------
step-1:
	<a href="/update/{{emp.id}}">Update</a>

step-2:
	path('update/<int:id>', views.update_view)

views.py
------------
def update_view(request,id):
    employee = Employee.objects.get(id=id)
    form = EmployeeForm(instance=employee)
    return render(request,'testapp/update.html',{'form':form})

update.html
-------------------
<!DOCTYPE html>
{% extends 'testapp/base.html' %}
{% block body_block %}
<h1>Employee Update Form</h1><hr>
<form method="post">
    {{form.as_p}}
    {% csrf_token %}
    <input class="btn btn-success btn-lg" type="submit" value="Update Record">
</form>
{% endblock %}

if employee want to update record
-----------------------------------------------------
def update_view(request,id):
    employee = Employee.objects.get(id=id)
    form = EmployeeForm(instance=employee)
    if request.method == 'POST':
        form = EmployeeForm(request.POST,instance=employee)
        if form.is_valid():
            form.save()
        return redirect('/')
    return render(request,'testapp/update.html',{'form':form})

Types of Views:
	1.FBV's
	2.CBV's

Class Based View(CBV's):
-------------------------------------
1.FBVs are old where as CBVs are new. CBVs are introduces in Django1.3 version to implement generic views.
2.CBVs are very easy to use when copared with FBVs. The most commonly used type of views in real time is CBVs.
3.FBVS more powerful when compare with CBVs. If you are unable to handle with CBVs then only we have to go for FBVs.

CBVs meant for common requrement.
Ex:
	Read data from Employee table--->CBVs
	Complex operation over Employee and Customer tables simultaneously-->FBVs


Ex:
-----
django-admin startproject cbvproject
py manage.py startapp testapp
Add app in settings.py

views.py
------------
from django.views.generic import View
from django.http import HttpResponse
class HelloWorldView(View):
    def get(self,request):
        return HttpResponse('<h1>This response is from class based view</h1>')

urls.py:
	path('hello/',views.HelloWorldView.as_view())

Note:
--------
1).While defining class based view we have to extend View class.
2).To provide response to GET request django will always call get() method. Hence we have to override this method in our class. Similarly other http methods post(), put(), patch(), delete().....
3).While defining url pattern we have to use as_view() method.

Template based app by using CBVs:
------------------------------------------------------
views.py
-------------
from django.views.generic import TemplateView
class TemplateCBV(TemplateView):
    template_name = 'testapp/results.html'

results.html
-------------------
<body>
  <h1>Hello this is from tmplate based CBV</h1>
</body>

urls.py:
	path('tt/', views.TemplateCBV.as_view())

How to send context parameter:
------------------------------------------------
views.py
-------------
class TemplateCBV2(TemplateView):
    template_name = 'testapp/results2.html'
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['name'] = 'Sunny'
        context['marks'] = 98
        context['subject'] = 'Python'
        return context

results2.html
--------------------
<body>
    <h1>Student Information</h1>
    <h2>Student Name:{{name}}</h2>
    <h2>Student Marks:{{marks}}</h2>
    <h2>Student Subject:{{subject}}</h2>
</body>

urls.py:
	path('tt2/', views.TemplateCBV2.as_view())

Model related View classes to perform CRUD operations:
-------------------------------------------------------------------------------------
View
TemplateView

To perform CRUD operations, predefined View classes are:
	ListView			-->To select all records(R)
	DetailView		-->To get details of a particular record(R)
	CreateView		-->To insert a record(C)
	DeleteView		-->To delete a record(D)
	UpdateView		-->To update record(U)

1).ListView:
	We can use ListView class to list out all records from the DB(Model)
	It is alternative way to:ModelClassName.objects.all()

default template file name:modelname_list.html
default context object name:modelname_list

Ex:
django-admin startproject cbvproject2
py manage.py startapp testapp
Add app in settings.py

models.py
---------------
class Book(models.Model):
    title = models.CharField(max_length=30)
    author = models.CharField(max_length=30)
    pages = models.IntegerField()
    price = models.FloatField()

-->makemigrations and migrate

admin.py
-------------
from testapp.models import Book
class BookAdmin(admin.ModelAdmin):
    list_display = ['title','author','pages','price']
admin.site.register(Book,BookAdmin)

views.py
-------------
from django.views.generic import ListView
from testapp.models import Book
class BookListView(ListView):
    model = Book

urls.py:
	path('list/', views.BookListView.as_view())

book_list.html
----------------------
<body>
  <h1>All Books Information</h1>
  {% for book in book_list %}
  <ul>
    <li>Title:<strong>{{book.title}}</strong></li>
    <li>Author:<strong>{{book.author}}</strong></li>
    <li>Pages:<strong>{{book.pages}}</strong></li>
    <li>Price:<strong>{{book.price}}</strong></li>
  </ul>
  <hr>
  {% endfor %}
</body>

how to configure our own tempate file and context object:
-----------------------------------------------------------------------------------------
By using template_name & context_object_name variables

views.py
------------
class BookListView(ListView):
    model = Book
    template_name = 'testapp/books.html'
    context_object_name = 'books'

books.html
-----------------
<body>
<div class="container">
  <h1>All Books Information from customized template file</h1>
  {% for book in books %}
  <ul>
    <li>Title:<strong>{{book.title}}</strong></li>
    <li>Author:<strong>{{book.author}}</strong></li>
    <li>Pages:<strong>{{book.pages}}</strong></li>
    <li>Price:<strong>{{book.price}}</strong></li>
  </ul>
  <hr>
  {% endfor %}
</div>
</body>